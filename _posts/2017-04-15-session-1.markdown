---
layout: post
title: 深入解析 Session 技术
date: 2017-04-15 10:32:24.000000000 +09:00
---

## <span id="0">目录</span>
>* [**1 引言**](#1)
>* [**2 Session 基础知识**](#2)
>* [2.1 Session 机制](#2.1)
>* [2.2 Session 技术](#2.2)
>* [2.3 Session ID 传递](#2.3)
>* [**9 Cookie 与 Session 的区别**](#9)
>* [**10 Cookie 与 Session 的问答**](#10)
>* [**11 参考文章**](#11)


# [<span id="1">1 引言</span>](#0)
在 web 应用开发中保持 HTTP 链接状态的技术有两个：一个是 Cookie 技术，另一个则是 Session 技术。
Cookie 技术是客户端的解决方案。具体详情可参考[ 深入解析 Cookie 技术 ](http://wangxiong.me/2017/04/cookie-1/)一文。
Session 技术则是服务端的解决方案，它是通过服务器来保持状态的。Session 是解决 HTTP 协议无状态问题的服务端解决方案，
它能让客户端和服务端一系列交互动作变成一个完整的事务，能使网站变成一个真正意义上的软件。
# [<span id="2">2 Session 基础知识</span>](#0)
# [<span id="2.1">2.1 Session 机制</span>](#0)
Session 是另一种记录客户状态的机制，不同的是 Cookie 保存在客户端浏览器中，而 Session 保存在服务器上。
客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是 Session 。
客户端浏览器再次访问时只需要从该 Session 中查找该客户的状态就可以了。

如果说 Cookie 机制是通过检查客户身上的“通行证”来确定客户身份的话，那么 Session 机制就是通过检查服务器上的“客户明细表”来确认客户身份。
Session 相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。
## [<span id="2.2">2.2 Session 技术</span>](#0)
在服务器端为每台浏览器，建立一个独立的数据区域，然后将服务器端的每个数据区与具体的浏览器联系起来，
最后为每个数据区分配一个位置标识，浏览器去保存该标识。只要浏览器请求服务器时携带了正确的标识，就可获得响应的数据。
> 标识：称之为 SessionID ，存储在浏览器中的 Cookie 中，每次请求都必须携带。
> 数据区：服务器端存储会话数据，也就是 Session 数据。

## [<span id="2.3">2.3 Session ID 传递</span>](#0)
Session 终究是因为管理用户状态信息才存在的。每个来访问用户都会被分配一个唯一的 ```session_id```，用于区分其它用户的 Session 数据。
用户一旦从被分配了 ```session_id``` 之后的每次访问(HTTP请求)都会携带这个 ```session_id``` 给服务端，用于加载该用户的 Session 数据。
### 传递方法
客户端与服务端的 Web 通信协议是 HTTP。而 PHP 通过 HTTP 取得用户数据惯用的三种方法分别是:POST 方法、GET 方法还有 Cookie 。
而 PHP 默认传递方法正是 Cookie ,也是最佳方法。只有在客户端不支持 Cookie 的时候(浏览器禁用了 Cookie 功能)
才会通过 GET 方法来传递 ```session_id```，即通过在 URL 的```query_string```部分传递 ```session_id```。
### 传递过程
用户通过浏览器访问网页，将 URL 输入地址栏回车，浏览器发出请求，在调用 Sockect Send 之前浏览器引擎会搜索有效的 Cookies 记录并
封装在 HTTP 请求头的 Cookie 字段一同发送出去。服务端器接收到请求后，交给 PHP 处理。 这时，Session 初始化函数如果在```$_COOKIE```中
没有找到以```session_name()```作为键值存储的元素(值为```session id```)，则会以为用户是第一次访问 Web 。
作为第一次访问的用户，Session 初始化函数总会随机生成一个```session_id```并且通过```setcookie()```函数调用将新生成的
```session_id```以```session_name = session_id```的格式填入HTTP响应头```Set-Cookie```字段，发送给客户端
（这样接下来的请求， HTTP 请求头 Cookie 字段都会携带该 Cookie 记录给 Web 服务器）。
如果初始化函数发现用户端 Cookies 中已定义了存在 ```$_COOKIE['session_name']```，
则会加载与 ```$_COOKIE['session_name']``` 相对应的 Session 文件(```$_COOKIE['session_name']```就是 ```session_id```)。
如果用户 Cookie 记录过期，则会被浏览器删除。之后的下一次请求，服务器会以为用户又是第一次访问，如此循环。



















# [<span id="9">9 Cookie 与 Session 的区别</span>](#0)
如果一位顾客经常去一家咖啡店有喝5杯咖啡免费赠一杯咖啡的优惠，然而一次性消费5杯咖啡的机会微乎其微，这时就需要某种方式来纪录顾客的消费数量。
想象一下其实也无外乎下面的几种方案：
* 该店的店员很厉害，能记住每位顾客的消费数量，只要顾客一走进咖啡店，店员就知道该怎么对待了。这种做法就是```协议本身支持```状态。
* 发给顾客一张卡片，上面记录着消费的数量，一般还有个有效期限。每次消费时，如果顾客出示这张卡片，则此次消费就会与以前或以后的消费相联系起来。这种做法就是在```客户端保持```状态。
* 发给顾客一张会员卡，除了卡号之外什么信息也不纪录，每次消费时，如果顾客出示该卡片，则店员在店里的纪录本上找到这个卡号对应的纪录添加一些消费信息。这种做法就是在```服务器端保持```状态。
由于HTTP协议是无状态的，而出于种种考虑也不希望使之成为有状态的，因此，后面两种方案就成为现实的选择。具体来说 Cookie 机制
采用的是在客户端保持状态的方案，而 Session 机制采用的是在服务器端保持状态的方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，
所以 Session 机制可能需要借助于 Cookie 机制来达到保存标识的目的，但实际上它还有其他选择。

# [<span id="11">11 参考文章</span>](#0)
[百科-Session机制](http://baike.sogou.com/v62020984.htm?fromTitle=Session%E6%9C%BA%E5%88%B6)
